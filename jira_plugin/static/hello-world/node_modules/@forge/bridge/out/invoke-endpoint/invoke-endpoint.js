"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports._invokeEndpointFn = exports.InvokeType = void 0;
const bridge_1 = require("../bridge");
const errors_1 = require("../errors");
const utils_1 = require("../utils");
const MAX_NUM_OPERATIONS = 500;
const OPERATION_INTERVAL_SEC = 25;
const OPERATION_INTERVAL_MS = 1000 * OPERATION_INTERVAL_SEC;
var InvokeType;
(function (InvokeType) {
    InvokeType["REMOTE"] = "Remote";
    InvokeType["SERVICE"] = "Container";
})(InvokeType = exports.InvokeType || (exports.InvokeType = {}));
const callBridge = (0, bridge_1.getCallBridge)();
const validatePayload = (payload) => {
    if (!payload)
        return;
    if (Object.values(payload).some((val) => typeof val === 'function')) {
        throw new errors_1.BridgeAPIError('Passing functions as part of the payload is not supported!');
    }
};
const _setupInvokeEndpointFn = (invokeType) => async (input) => {
    validatePayload(input);
    const callBridgePayload = {
        ...input,
        invokeType: `ui-${invokeType.toLowerCase()}-fetch`
    };
    const bridgeResponse = await callBridge('invoke', callBridgePayload);
    const { success, payload, error } = bridgeResponse !== null && bridgeResponse !== void 0 ? bridgeResponse : {};
    const response = { ...(success ? payload : error) };
    if (response && response.headers) {
        for (const header in response.headers) {
            if (Array.isArray(response.headers[header])) {
                response.headers[header] = response.headers[header].join(',');
            }
        }
    }
    return response;
};
const _invokeEndpointFn = (invokeType) => {
    const invokeEndpointFn = _setupInvokeEndpointFn(invokeType);
    return (0, utils_1.withRateLimiter)(invokeEndpointFn, MAX_NUM_OPERATIONS, OPERATION_INTERVAL_MS, `${invokeType} invocation calls are rate limited at ${MAX_NUM_OPERATIONS}/${OPERATION_INTERVAL_SEC}s`);
};
exports._invokeEndpointFn = _invokeEndpointFn;
