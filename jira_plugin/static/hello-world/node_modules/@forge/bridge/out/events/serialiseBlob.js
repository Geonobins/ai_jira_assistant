"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.containsSerialisedBlobs = exports.containsBlobs = exports.deserialiseBlobsInPayload = exports.serialiseBlobsInPayload = void 0;
const blobParser_1 = require("../utils/blobParser");
const isPlainObject = (value) => {
    if (typeof value !== 'object' || value === null)
        return false;
    if (Object.prototype.toString.call(value) !== '[object Object]')
        return false;
    const proto = Object.getPrototypeOf(value);
    if (proto === null)
        return true;
    const Ctor = Object.prototype.hasOwnProperty.call(proto, 'constructor') && proto.constructor;
    return (typeof Ctor === 'function' &&
        Ctor instanceof Ctor &&
        Function.prototype.call(Ctor) === Function.prototype.call(value));
};
const blobToBase64WithMetadata = async (blob) => {
    const base64Data = await (0, blobParser_1.blobToBase64)(blob);
    return {
        data: base64Data,
        type: blob.type
    };
};
const base64WithMetadataToBlob = (metadata) => {
    return (0, blobParser_1.base64ToBlob)(metadata.data, metadata.type);
};
const serialiseBlobsInPayload = async (payload) => {
    if (payload instanceof Blob) {
        const blobData = await blobToBase64WithMetadata(payload);
        return {
            ...blobData,
            __isBlobData: true
        };
    }
    if (Array.isArray(payload)) {
        return Promise.all(payload.map((item) => (0, exports.serialiseBlobsInPayload)(item)));
    }
    if (payload && isPlainObject(payload)) {
        const entries = await Promise.all(Object.entries(payload).map(async ([key, value]) => [key, await (0, exports.serialiseBlobsInPayload)(value)]));
        return Object.fromEntries(entries);
    }
    return payload;
};
exports.serialiseBlobsInPayload = serialiseBlobsInPayload;
const deserialiseBlobsInPayload = (payload) => {
    if (payload && isPlainObject(payload) && '__isBlobData' in payload) {
        const typedData = payload;
        return base64WithMetadataToBlob({
            data: typedData.data,
            type: typedData.type
        });
    }
    if (Array.isArray(payload)) {
        return payload.map((item) => (0, exports.deserialiseBlobsInPayload)(item));
    }
    if (payload && isPlainObject(payload)) {
        const result = {};
        for (const [key, value] of Object.entries(payload)) {
            result[key] = (0, exports.deserialiseBlobsInPayload)(value);
        }
        return result;
    }
    return payload;
};
exports.deserialiseBlobsInPayload = deserialiseBlobsInPayload;
const containsBlobs = (payload) => {
    if (payload instanceof Blob) {
        return true;
    }
    if (Array.isArray(payload)) {
        return payload.some((item) => (0, exports.containsBlobs)(item));
    }
    if (payload && isPlainObject(payload)) {
        return Object.values(payload).some((value) => (0, exports.containsBlobs)(value));
    }
    return false;
};
exports.containsBlobs = containsBlobs;
const containsSerialisedBlobs = (payload) => {
    if (payload && isPlainObject(payload) && '__isBlobData' in payload) {
        return true;
    }
    if (Array.isArray(payload)) {
        return payload.some((item) => (0, exports.containsSerialisedBlobs)(item));
    }
    if (payload && isPlainObject(payload)) {
        return Object.values(payload).some((value) => (0, exports.containsSerialisedBlobs)(value));
    }
    return false;
};
exports.containsSerialisedBlobs = containsSerialisedBlobs;
